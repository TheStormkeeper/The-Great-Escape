<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Great Escape: Routine at AFDF</title>
<link rel="stylesheet" type="text/css" href="../TheGreatEscape.css" />
</head>
<body class="disassembly">
<table class="header">
<tr>
<td class="headerLogo"><a class="link" href="../index.html"><img src="../images/logo.png" alt="The Great Escape" /></a></td>
<td class="headerText">Routines</td>
</tr>
</table>
<table class="prevNext">
<tr>
<td class="prev">Prev: <a class="link" href="44943.html">AF8F</a></td>
<td class="up">Up: <a class="link" href="../maps/all.html#45023">Map</a></td>
<td class="next">Next: <a class="link" href="45319.html">B107</a></td>
</tr>
</table>
<div class="description">AFDF: sub_AFDF</div>
<table class="disassembly">
<tr>
<td class="routineComment" colspan="3">
<div class="details">
<div class="paragraph">
Used by the routines at <a class="link" href="44943.html">AF8F</a> and <a class="link" href="50400.html">C4E0</a>.
</div>
</div>
</td>
</tr>
<tr>
<td class="label"><a name="45023"></a>AFDF</td>
<td class="instruction">LD HL,$8001</td>
<td class="comment">HL = $8001; // &amp;vischar[0].byte1;</td>
</tr>
<tr>
<td class="address"><a name="45026"></a>AFE2</td>
<td class="instruction">LD B,$08</td>
<td class="comment">B = 8; // 8 iterations</td>
</tr>
<tr>
<td class="label"><a name="45028"></a>AFE4</td>
<td class="instruction">BIT 7,(HL)</td>
<td class="comment" rowspan="3051">do { if (*HL &amp; vischar_BYTE1_BIT7) goto next; // $8001, $8021, ...} PUSH BC PUSH HL {  HL += 0x0E; // $800F etc. - y axis position } {  C = *HL++; } B = *HL; EX DE,HL HL = word_81A4; {  BC += 4; } {  if (HL != BC) { } if (HL &gt; BC) goto pop_next; {    BC -= 8; // ie -4 over original } {    HL = word_81A4; } if (HL &lt; BC) goto pop_next; } EX DE,HL HL++; {  C = *HL++; } B = *HL; EX DE,HL HL = word_81A6; {  BC += 4; } {  if (HL != BC) { } if (HL &gt; BC) goto pop_next; {    BC -= 8; } {    HL = word_81A6; } if (HL &lt; BC) goto pop_next; EX DE,HL HL++; C = *HL; {  A = word_81A8 - C; } if (A &gt;= 0) goto $B046; A = -A; {  if (A &gt;= 24) goto pop_next; } {  A = IY[1] &amp; 0x0F; // sampled IY=$8020, $8040, $8060, $8000 // but this is *not* vischar_BYTE1_MASK} {  if (A == 1) { } POP HL PUSH HL HL--; A = L; A &amp;= A; if (A == 0) { A = bribed_character; {      if (A == *IY) { } use_bribe(); } else { POP HL POP BC {        HL = IY + 1; } solitary(); return; // exit via } } } POP HL HL--; A = *HL; // sampled HL = $80C0, $8040, $8000, $8020, $8060 // vischar_BYTE0 {  if (A &gt;= 26) { } PUSH HL - {    HL += 17; } - BC = 0x0723; CP 28       // if (A != 28) ... A = IY[14]; // interleaved JR NZ,$B08F // ... goto $B08F; {    L -= 2; } C = 54; A ^= 1; {    if (A == 0) { } A = *HL; {      if (A != C) { } {        if (A &gt;= C) (*HL) -= 2; } (*HL)++; } } {    else if (A == 1) { } {      A = C + B; } {      if (A != *HL) (*HL)++; } } {    else if (A == 2) { } {      A = C - B; } *HL = A; } else { {      A = C - B; } {      if (A != *HL) (*HL)--; } } POP HL POP BC } {  HL += 13; } {  A = *HL &amp; vischar_BYTE13_MASK; // sampled HL = $806D, $804D, $802D, $808D, $800D} if (A) { HL++; {    A = *HL ^ 2; } {    if (A != IY[14]) { } IY[13] = 0x80; {      IY[7] = (IY[7] &amp; vischar_BYTE7_MASK_HI) | 5; // preserve flags and set 5? // sampled IY = $8000, $80E0 } if (!Z) return; /* odd */ } } {  BC = IY[14]; // sampled IY = $8000, $8040, $80E0} {  IY[13]  = four_bytes_B0F8[BC]; } {  if ((C &amp; 1) == 0) { } IY[7] &amp;= ~vischar_BYTE7_BIT5; goto $B0D0; } else { IY[7] |= vischar_BYTE7_BIT5; goto $B0D0; } four_bytes_B0F8 pop_next: POP HL POP BC {  next: HL += 32; } {} while (--B); } return; increase_morale_by_10_score_by_50(); IY[1] = 0; {HL = IY + 2; } sub_CA81:$CB23(); DE = &amp;items_held[0]; {if (*DE != item_BRIBE) goto got_bribe; } {if (*++DE != item_BRIBE) return; // have no bribes } {got_bribe: *DE = item_NONE; } {item_structs[item_BRIBE].room = itemstruct_ROOM_MASK;} draw_all_items(); B = 7; // 7 iterations HL = $8020; // iterate over non-player characters {do { if (HL[0] &lt; 20) { // likely character index. but why 20? } {    HL[1] = vischar_BYTE1_BIT2; } // character has taken bribe? } {  HL += 32; } } while (--B); {queue_message_for_display(message_HE_TAKES_THE_BRIBE); } queue_message_for_display(message_AND_ACTS_AS_DECOY); return; {if (indoor_room_index) { indoor_bounds_check(); return; } } B = 24; // 24 iterations (includes walls and fences) DE = &amp;walls[0]; do { PUSH BC - {  BC = DE[0] * 8; } {  if (word_81A4 &lt; BC + 2) goto next; } {  BC = DE[1] * 8; } {  if (word_81A4 &gt;= BC + 4) goto next; } {  BC = DE[2] * 8; } {  if (word_81A6 &lt; BC) goto next; } {  BC = DE[3] * 8; } {  if (word_81A6 &gt;= BC + 4) goto next; } {  BC = DE[4] * 8; } {  if (word_81A8 &lt; BC) goto next; } {  BC = DE[5] * 8; } {  if (word_81A8 &gt;= BC + 2) goto next; } - POP BC {  IY[7] ^= vischar_BYTE7_BIT5; // sampled IY = $80A0, $8080, $8060 } A |= 1; // return NZ return; next: - POP BC {  DE += 6; } {} while (--B); } A &amp;= B; // return Z return; B = 0; A &lt;&lt;= 1; B = (B &lt;&lt; 1) + carry; A &lt;&lt;= 1; B = (B &lt;&lt; 1) + carry; A &lt;&lt;= 1; B = (B &lt;&lt; 1) + carry; C = A; return; {C = current_door &amp; gates_and_doors_MASK; } HL = &amp;gates_and_doors[0]; B = 9; // 9 iterations {do { if (*HL &amp; gates_and_doors_MASK == C) { } {    if ((*HL &amp; gates_and_doors_LOCKED) == 0) return; // unlocked } queue_message_for_display(message_THE_DOOR_IS_LOCKED); A |= 1; // set NZ return; } HL++; } while (--B); A &amp;= B; // set Z (B is zero) return; A = indoor_room_index; {if (A) goto door_handling_indoors; // exit via? } HL = &amp;door_positions[0]; E = IY[14]; {if (E &gt;= 2) HL = &amp;door_position[1]; } D = 3;  // mask B = 16; {do { A = *HL &amp; D; } {  if (A == E) { } PUSH BC PUSH HL PUSH DE door_in_range(); POP DE POP HL POP BC if (!C) goto found; } {  HL += 8; } } while (--B); A &amp;= B; // set Z (B is zero) return; {found: A = 16 - B; } current_door = A; EXX is_door_open(); if (!Z) return; // door was locked EXX {IY[28] = (*HL &gt;&gt; 2) &amp; 0x3F; // sampled HL = $792E (in door_positions[]) } {if ((*HL &amp; 3) &gt;= 2) { } {  HL += 5; } transition(); return; } // seems to goto reset then jump back to main (icky) {else { HL -= 3; } transition(); return; } {A = HL[1]; } - BC_becomes_A_times_4(); {if (word_81A4 &lt; BC - 3 || word_81A4 &gt;= BC + 3) return; // with C set } - {A = HL[2]; } BC_becomes_A_times_4(); - {if (word_81A6 &lt; BC - 3 || word_81A6 &gt;= BC + 3) return; // with C set } return; // C not set B = 0; A &lt;&lt;= 1; B = (B &lt;&lt; 1) + carry; A &lt;&lt;= 1; B = (B &lt;&lt; 1) + carry; C = A; return; {BC = &amp;four_byte_structures[first_byte_of_room_structure]; } HL = &amp;word_81A4; A = *BC; {if (A &lt; *HL) goto $B2E7; } {A = *++BC + 4; } {if (A &gt;= *HL) goto $B2E7; } {HL += 2; } DE++; // Stray code? DE is incremented but not used. {A = *++BC - 4; } {if (A &lt; *HL) goto $B2E7; } {A = *++BC; } {if (A &gt;= *HL) goto $B2E7; } HL = &amp;byte_81BF[0]; {B = *HL; // iterations } {if (B == 0) return; } HL++; do { PUSH BC PUSH HL DE = &amp;word_81A4; B = 2; // 2 iterations do { A = *DE; {    if (A &lt; HL[0] || A &gt;= HL[1]) goto $B2F2; // next outer loop iteration (eg break) } {    DE += 2; } HL += 2; // increment moved - hope it's still correct } while (--B); POP HL POP BC {  IY[7] ^= 0x20; // stop character? } A |= 1; return; // return NZ POP HL {  HL += 4; } POP BC } while (--B); A &amp;= B; // B is zero here return; // return Z HL = $8000; reset_something(); HL = $8018; {A = *HL++; } C = *HL; divide_by_8(C,A); {map_position[0] = A - 11; } HL++; {A = *HL++; } C = *HL; divide_by_8(C,A); {map_position[1] = A - 6; } {indoor_room_index = room_NONE; } get_supertiles(); sub_A8A2(); setup_movable_items(); zoombox(); return; HL = &amp;door_related; for (;;) { A = *HL; {  if (A == 255) return; } - current_door = A; get_door_position(); A = *HLdash; Cdash = A; {  Bdash = A &amp; 3; } {  if (IY[14] &amp; 3 != Bdash) goto next; } HLdash++; - // registers renamed here DEdash = &amp;word_81A4; B = 2; // 2 iterations {  do { A = *HLdash - 3; } {    if (A &gt;= *DEdash || A + 6 &lt; *DEdash) goto next; // -3 .. +3 } {    DEdash += 2; } HLdash++; } while (--Bdash); HLdash++; - PUSH HLdash PUSH BCdash is_door_open(); POP BCdash POP HLdash if (!Z) return; // door was closed {  IY[28] = (Cdash &gt;&gt; 2) &amp; 0x3F; } HLdash++; {  if (current_door &amp; (1&lt;&lt;7)) { HLdash -= 8; } // unsure if this flag is gates_and_doors_LOCKED } transition(); return; // exit via // with banked registers... next: - HL++; } {item_structs[item_RED_CROSS_PARCEL].room = itemstruct_ROOM_MASK; // room_NONE &amp; 0x3F;} HL = &amp;items_held; {if (*HL != item_RED_CROSS_PARCEL) HL++; // one or the other must be a red cross parcel item } *HL = item_NONE; // no longer have parcel (we assume one slot or the other has it) draw_all_items(); A = red_cross_parcel_current_contents; drop_item_A(); {queue_message_for_display(message_YOU_OPEN_THE_BOX); } increase_morale_by_10_score_by_50(); return; // exit via HL = $8020; // iterate over non-player characters B = 7; // 7 iterations do { A = *HL; {  if ((A != character_NONE) &amp;&amp; (A &gt;= character_20_prisoner)) goto found; } {  HL += 32; // sizeof a character struct } } while (--B); return; found: bribed_character = A; {HL[1] = 1; // $8021 etc. // room index? room_1_hut1right} return; Load items_held. Load item_FOOD. Is 'low' slot item_FOOD? Yes - goto have_food. Is 'high' slot item_FOOD? No - return. have_food: (test a character flag?) Bit 5 set? Yes - return. Set bit 5. {Set item_attribute: FOOD to bright-purple/black. } draw_all_items() goto increase_morale_by_10_score_by_50 HL = $8015; // current character sprite set DE = &amp;sprite_guard_tl_4; {if (*HL == E) return; // cheap equality test // already in uniform } {if (indoor_room_index &gt;= room_29_secondtunnelstart) return; // can't don uniform when in a tunnel } *HL++ = E; {*HL = D; } increase_morale_by_10_score_by_50(); return; {if (indoor_room_index != room_50_blocked_tunnel) return; } {if (roomdefn_50_blockage == 255) return; // blockage already cleared } {roomdefn_50_blockage = 255; } {roomdefn_50_collapsed_tunnel_obj = 0; // remove blockage graphic} setup_room(); choose_game_screen_attributes(); plot_indoor_tiles(); increase_morale_by_10_score_by_50(); return; // exit via HL = &amp;fences[0] + 3; DE = &amp;player_map_position_y; B = 4; // iterations do { ... A = *DE; {  if (A &gt;= *HL) goto continue; } HL--; {  if (A &lt; *HL) goto continue; } DE--; // &amp;player_map_position_x; A = *DE; HL--; {  if (A == *HL) goto set_to_4; } A--; {  if (A == *HL) goto set_to_6; } DE++; // reset to Y continue: ... {  HL += 6; // array stride } } while (--B); DE--; // &amp;player_map_position_x; {HL -= 3; // pointing to $B59E } B = 3; // iterations do { ... A = *DE; {  if (A &lt; *HL) goto continue2; } HL++; {  if (A &gt;= *HL) goto continue2; } DE++; A = *DE; HL++; {  if (A == *HL) goto set_to_5; } A--; {  if (A == *HL) goto set_to_7; } DE--; continue2: ... {  HL += 6; // array stride } } while (--B); {return; } {set_to_5: A = 5; goto action_wiresnips_tail; // crawl TR} {set_to_6: A = 6; goto action_wiresnips_tail; // crawl BR} set_to_7: A = 7;                             // crawl BL action_wiresnips_tail: ... {$800E = A; } {$800D = 0x80; } {$8001 = 2; } {$8013 = 12; // set vertical offset } {$8015 = sprite_prisoner_tl_4; } {user_locked_out_until = game_counter + 96; } {queue_message_for_display(message_CUTTING_THE_WIRE); } open_door(); if (!Z) return; // wrong door? ptr_to_door_being_lockpicked = HL; {user_locked_out_until = game_counter + 0xFF; } {($8001) = vischar_BYTE1_PICKING_LOCK; } {queue_message_for_display(message_PICKING_THE_LOCK); } A = room_22_redkey; goto action_key; A = room_13_corridor; goto action_key; A = room_14_torch; PUSH AF open_door(); POP BC if (!Z) return; // wrong door? {A = *HL &amp; ~gates_and_doors_LOCKED; // mask off locked flag} if (A != B) { B = message_INCORRECT_KEY; } else { *HL &amp;= ~gates_and_doors_LOCKED; // clear the locked flag increase_morale_by_10_score_by_50(); B = message_IT_IS_OPEN; } queue_message_for_display(B); {if (indoor_room_index == 0) goto outdoors; else goto indoors; } outdoors: B = 5; // 5 iterations (they must overlap) HL = &amp;gates_flags; {do { A = *HL &amp; ~gates_and_doors_LOCKED; } EXX get_door_position(); PUSH HL door_in_range(); POP HL if (!C) goto return_zero; // in range {  HL += 4; } door_in_range(); if (!C) goto return_zero; // in range EXX HL++; } while (--B); return; return_zero: EXX A = 0; // ok return; indoors: HL = &amp;door_flags; B = 8; // 8 iterations {do { C = *HL &amp; ~gates_and_doors_LOCKED; } DE = &amp;door_related; for (;;) { A = *DE; {    if (A != 0xFF) { } {      if ((A &amp; 0x7F) == C) goto found; // 0x7F is likely ~gates_and_doors_LOCKED but unsure } {      DE++; } } } HL++; } while (--B); A |= 1; // not ok return; found: A = *DE; EXX get_door_position(); HL++; EX DE,HL HL = &amp;word_81A4; B = 2; // 2 iterations {do { if (*HL &lt;= *DE - 3 || *HL &gt; *DE + 3) goto exx_next; } {  HL += 2; } DE++; } while (--B); EXX A = 0; // ok return; exx_next: EXX goto next; B = 8; IY = $8000; do { A = IY[1]; {  if (A == 0xFF) goto next; } PUSH BC IY[1] |= vischar_BYTE1_BIT7; // $8001 {  if (IY[13] &amp; vischar_BYTE13_BIT7) goto $B6BE; // $800D} H = IY[11]; L = IY[10]; A = IY[12]; {  if (even_parity(A)) goto $B64F; } A &amp;= 0x7F; if (A == 0) goto $B6C2; {  HL += (A + 1) * 4 - 1; } A = *HL++; {  EX AF,AF' } EX DE,HL L = IY[15]; // Y axis H = IY[16]; A = *DE; // sampled DE = $CF9A, $CF9E, $CFBE, $CFC2, $CFB2, $CFB6, $CFA6, $CFAA (character_related_data) C = A; A &amp;= 0x80; {  if (A) A = 0xFF; } B = A; HL -= BC; word_81A4 = HL; DE++; L = IY[17]; // X axis H = IY[18]; A = *DE; C = A; A &amp;= 0x80; {  if (A) A = 0xFF; } B = A; HL -= BC; word_81A6 = HL; DE++; L = IY[19]; // vertical offset H = IY[20]; A = *DE; C = A; A &amp;= 0x80; {  if (A) A = 0xFF; } B = A; HL -= BC; word_81A8 = HL; sub_AF8F(); if (!Z) goto $B6A8; IY[12]--; goto $B6A2; {  if (A == *HL) goto $B6C2; } {  HL += (A + 1) * 4; } EX DE,HL A = *DE; L = A; A &amp;= 0x80; {  if (A) A = 0xFF; } H = A; C = IY[15]; // Y axis B = IY[16]; HL += BC; word_81A4 = HL; DE++; A = *DE; L = A; A &amp;= 0x80; {  if (A) A = 0xFF; } H = A; C = IY[17]; // X axis B = IY[18]; HL += BC; word_81A6 = HL; DE++; A = *DE; L = A; A &amp;= 0x80; {  if (A) A = 0xFF; } H = A; C = IY[19]; // vertical offset B = IY[20]; HL += BC; word_81A8 = HL; DE++; A = *DE; EX AF,AF' sub_AF8F(); if (!Z) goto $B6A8; IY[12]++; {  HL = IY; } reset_something:$B729(); POP BC A = IY[1]; // $8001 {  if (A != 0xFF) IY[1] &amp;= ~vischar_BYTE1_BIT7; } next: DE = 32; // stride IY += DE; {} while (--B); } return; IY[13] &amp;= ~(1&lt;&lt;7); {A = byte_CDAA[IY[14] * 9 + IY[13]]; } C = A; L = IY[8]; H = IY[9]; A += A; E = A; HL += DE; E = *HL; HL++; IY[10] = E; D = *HL; IY[11] = D; {if ((C &amp; (1&lt;&lt;7)) == 0) { } IY[12] = 0; {  DE += 2; } A = *DE; IY[14] = A; {  DE += 2; } EX DE,HL JP $B65A } A = *DE; C = A; A |= 0x80; IY[12] = A; {A = *++DE; } IY[14] = A; {DE += 3; } PUSH DE EX DE,HL {HL += C * 4 - 1; } A = *HL; EX AF,AF' POP HL JP $B605 PUSH HL {memcpy(&amp;word_81A4, HL + 15, 6); // DE/HL updated CHECK } POP HL EX DE,HL {DE += 24; } {HL = word_81A6 + 0x0200; } // A &amp;= A; // reset carry before SBC HL -= word_81A4; HL += HL; EX DE,HL {*HL++ = E; } {*HL++ = D; } EX DE,HL HL = 0x0800; A &amp;= A; // reset carry before SBC {HL -= word_81A4; } {HL -= word_81A8; } HL -= word_81A6; EX DE,HL {*HL++ = E; } *HL = D; return; BC = 0x1000; // B = 16, C = 0 do { PUSH BC item_discovered(); POP BC C++; } while (--B); {message_queue_pointer = message_queue + 2; } reset_map_and_characters(); {($8001) = 0; } HL = &amp;score_digits[0]; B = 10; // iterations {do { *HL++ = 0; } } while (--B); // could do a memset morale = morale_MAX; plot_score(); {items_held = 0xFFFF; } draw_all_items(); {$8015 = sprite_prisoner_tl_4; } {indoor_room_index = room_2_hut2left; } player_sleeps(); transition:$68F4(); return; B = 7; // iterations HL = $8020; // iterate over non-player characters {do { } {  reset_visible_character(); } {  HL += 32; } } while (--B); {dispatch_counter = 7; } {day_or_night = 0; } ($8001) = 0; // flags {collapsed_tunnel_obj = interiorobject_COLLAPSED_TUNNEL;} {blockage = 0x34; } HL = &amp;gates_and_doors[0]; B = 9; // 9 iterations {do { *HL++ |= gates_and_doors_LOCKED; } } while (--B); B = 6; // iterations {HL = &amp;beds[0]; } {do { E = *HL++; } {  D = *HL++; } *DE = interiorobject_OCCUPIED_BED; } while (--B); {bench_A = interiorobject_EMPTY_BENCH; } bench_B = interiorobject_EMPTY_BENCH; bench_C = interiorobject_EMPTY_BENCH; bench_D = interiorobject_EMPTY_BENCH; bench_E = interiorobject_EMPTY_BENCH; bench_F = interiorobject_EMPTY_BENCH; bench_G = interiorobject_EMPTY_BENCH; DE = &amp;character_structs[12].BYTE1; C = 10; // iterations HL = &amp;character_reset_data[0]; do { B = 3; // iterations {  do { *DE++ = *HL++; } {  } while (--B); } {  *DE++ = 0x12; // reset to 0x12 but the initial data is 0x18} {  *DE++ = 0x00; } {  DE += 2; } {  if (C == 7) DE = &amp;character_structs[20].BYTE1; } {} while (--C); } return; {... } {HL = IY; } {if (L) return; // skip non-player character } HL = $8131; BC = 0x0804; // 8 iterations, C is ? {do { if (*HL != 0) goto $B860; } {  HL += 4; } } while (--B); HL = &amp;searchlight_state; (*HL)--; {if (0xFF != *HL) return; } choose_game_screen_attributes(); set_game_screen_attributes(); return; {searchlight_state = searchlight_STATE_1F; } return; sub_B89C(); if (!Z) return; {if ((A &amp; (1&lt;&lt;6)) == 0) { } setup_sprite_plotting(); if (!Z) goto searchlight; suspected_mask_stuff(); {  if (searchlight_state != searchlight_STATE_OFF) searchlight_sub(); } A = IY[0x1E]; {  if (A != 3) { } masked_sprite_plotter_24_wide(); goto searchlight; } if (Z) masked_sprite_plotter_16_wide_case_1(); // odd to test for Z since it's always set goto searchlight; } else { sub_DC41(); if (!Z) goto searchlight; suspected_mask_stuff(); masked_sprite_plotter_16_wide_case_1_searchlight(); goto searchlight; } BC = 0; {DE = 0; } A = 0xFF; EX AF,AF' EXX DE = 0; BC = 0x0820; // B = 8 iterations, C = stride, 32 HL = $8007; // vischar byte7 {do { if ((*HL &amp; vischar_BYTE7_BIT7) == 0) goto next; } PUSH HL PUSH BC {  HL += 8; // $8007 + 8 = $800F } {  C = *HL++; } B = *HL; {  BC += 4; } PUSH BC EXX POP HL SBC HL,BC EXX JR C,pop_next HL++; {  C = *HL++; } B = *HL; {  BC += 4; } PUSH BC EXX POP HL SBC HL,DE EXX JR C,pop_next HL++; POP BC PUSH BC {  A = 8 - B; } EX AF,AF'  // unpaired {  E = *HL++; } D = *HL; PUSH HL EXX POP HL {  L -= 2; } {  D = *HL--; } {  E = *HL--; } {  B = *HL--; } C = *HL; {  HL -= 15; } {  IY = HL; } EXX pop_next: POP BC POP HL {  next: HL += C; } } while (--B); sub_DBEB(); EX AF,AF' // return value {if (A &amp; (1&lt;&lt;7)) return; } {HL = IY; } {if ((A &amp; (1&lt;&lt;6)) == 0) { } IY[7] &amp;= ~vischar_BYTE7_BIT7; return; } {else { HL[1] &amp;= ~itemstruct_ROOM_FLAG_BIT6; } {  BIT 6,HL[1]  // odd. this tests the bit we've just cleared as if we're setting flags for return. but we can't be as we're followed by another instruction...} return; } {memset($8100, 0xFF, 0xA0); } {if (indoor_room_index) { } HL = &amp;byte_81DA; A = *HL; {  if (A == 0) return; } B = A; // iterations {  HL += 3; } } else { B = NELEMS(stru_EC01); // 59 iterations HL = $EC03; // stru_EC01 + 2 bytes } do { PUSH BC PUSH HL {  A = map_position_related_1 - 1; } {  if (A &gt;= *HL) goto pop_next; // HL[2] } {  if (A + 4 &lt; *--HL) goto pop_next; // HL[1] } {  HL += 3; } {  A = map_position_related_2 - 1; } {  if (A &gt;= *HL) goto pop_next; // HL[4] } {  if (A + 5 &lt; *--HL) goto pop_next; // HL[3] } {  HL += 2; } {  if (byte_81B2 &lt;= *HL++) goto pop_next; // HL[5] } {  if (byte_81B3 &lt; *HL++) goto pop_next; // HL[6] } A = byte_81B4; {  if (A) A--; } {  if (A &gt;= *HL) goto pop_next; // HL[7]; } {  HL -= 6; } A = map_position_related_1; C = A; {  if (A &gt;= *HL) { } A -= *HL; byte_B837 = A; HL++; {    A = *HL - C; } {    if (A &gt;= 3) A = 3; } {    ($B83A) = ++A; // word_B839 + 1 } } else { B = *HL; {    byte_B837 = 0; } {    C = 4 - (B - C); } HL++; {    A = (*HL - B) + 1; } {    if (A &gt; C) A = C; } ($B83A) = A; // word_B839 + 1 } HL++; A = map_position_related_2; C = A; {  if (A &gt;= *HL) { } A -= *HL; byte_B838 = A; {    A = *++HL - C; } {    if (A &gt;= 4) A = 4; } A++; {    ($B839) = A; } } else { B = *HL; {    byte_B838 = 0; } {    C = 5 - (B - C); } {    A = (*++HL - B) + 1; } {    if (A &gt;= C) A = C; } ($B839) = A; } HL--; BC = 0; {  if (byte_B838 == 0) C = -map_position_related_2 + *HL; } {  HL -= 2; } {  if (byte_B837 == 0) B = -map_position_related_1 + *HL; } HL--; A = *HL; - {  Adash = C * 32 + B; } {  HL = $8100 + Adash; } ($81A0) = HL; // $81A0 is a mystery location - {  DE = probably_mask_data_pointers[A]; } HL = word_B839; {  ($BA70) = L; // self modify } {  ($BA72) = H; // self modify } {  ($BA90) = *DE - H; // self modify // *DE looks like a count } {  ($BABA) = 32 - H; // self modify } PUSH DE {  E = *DE; } A = byte_B838; sub_BACD(); {  E = byte_B837; } HL += DE; POP DE HL++; // iterations do { A = *DE; // DE -&gt; $E560 upwards (in probably_mask_data) {    if (!even_parity(A)) { // uneven number of bits set} A &amp;= 0x7F; DE++; {      HL -= A; } if (HL &lt; 0) goto $BA69; DE++; if (DE) goto $BA4D; A = 0; goto $BA6C; } DE++; {  } while (--HL); } goto $BA6C; {  A = -L; } HL = ($81A0); // mystery C = 1; // self modified do { B = 1; // self modified do { - Adash = *DE; Adash &amp;= Adash; if (!P) { Adash &amp;= 0x7F; - DE++; A = *DE; } A &amp;= A; if (!Z) mask_against_tile(); L++; EX AF,AF' // unpaired? {      if (A != 0 &amp;&amp; --A != 0) DE--; } DE++; } while (--B); PUSH BC B = 1; // self modified - {    if (B) { } - {      if (A) goto $BAA3; } do { A = *DE; {        if (!even_parity(A)) { } A &amp;= 0x7F; DE++; {        B -= A; } if (B &lt; 0) goto $BAB6; DE++; if (!Z) goto $BA9B; EX AF,AF' // why not just jump instr earlier? // bank goto $BAB9; } DE++; } while (--B); A = 0; EX AF,AF' // why not just jump instr earlier? // bank goto $BAB9; A = -A; EX AF,AF' // bank } {    HL += 32; // self modified } EX AF,AF'  // unbank POP BC {  } while (--C); } pop_next: POP HL POP BC {  HL += 8; } {} while (--B); } B = 8; // iterations HL = 0; D = 0; // DE = 8; (unsure why this is reset) do { HL += HL; RLA  // carry = (A &gt;&gt; 7); A &lt;&lt;= 1; {  if (carry) HL += DE; } } while (--B); return; DEdash = HL - {HLdash = &amp;tiles[A]; } - Bdash = 8; // 8 iterations {do { *DEdash &amp;= *HLdash++; } {  DEdash += 4; // stride of 4 =&gt; supertile? } } while (--Bdash); - return; HL = &amp;map_position_related_1; {A = map_position[0] + 24; } A -= *HL; {if (A &gt; 0) { } CP IY[30]  // if (A ?? IY[30]) if (carry) { {    BC = A; } } else { {    A = *HL + IY[30]; } {    A -= map_position[0]; } {    if (A &lt;= 0) goto exit; } CP IY[30] if (carry) { C = A; {      B = -A + IY[30]; } } else { {      BC = IY[30]; } } } {  HL = ((map_position &gt;&gt; 8) + 17) * 8; } E = IY[26]; D = IY[27]; A &amp;= A; HL -= DE; {  if (result &lt;= 0) goto exit; } {  if (H) goto exit; } A = L; CP IY[31] if (carry) { {    DE = A; } } else { {    HL = IY[31] + DE; } {    DE = map_position &gt;&gt; 8 * 8; } A &amp;= A; // likely: clear carry HL -= DE; {    if (result &lt;= 0) goto exit; } {    if (H) goto exit; } A = L; CP IY[31] if (carry) { E = A; {      D = -A + IY[31]; } } else { {      DE = IY[31]; } } } A = 0; // return Z return; } exit: A = 0xFF; A &amp;= A; // return NZ return; B = 8; // iterations IY = $8000; do { PUSH BC {  if (IY[1] == room_NONE) goto next; } {  map_position_related_2 = (IY[26] &gt;&gt; 3) | (IY[27] &lt;&lt; 5); // divide by 8 } {  map_position_related_1 = (IY[24] &gt;&gt; 3) | (IY[25] &lt;&lt; 5); // divide by 8 } sub_BAF7(); {  if (A == 0xFF) goto next; // possibly not found case } {  A = ((E &gt;&gt; 3) &amp; 31) + 2; } PUSH AF {  A += map_position_related_2 - ((map_position &amp; 0xFF00) &gt;&gt; 8); } if (A &gt;= 0) { A -= 17; {    if (A &gt; 0) { } E = A; POP AF A -= E; if (carry) goto next; if (!Z) goto $BBF8; goto next; } } POP AF {  if (A &gt; 5) A = 5; } ($BC5F) = A; // self modify A = C; ($BC61) = A; // self modify ($BC89) = A; // self modify {  A = 24 - C; } ($BC8E) = A; // self modify A += $A8; ($BC95) = A; // self modify HL = &amp;map_position; A = B; A &amp;= A; A = 0; // interleaved if (Z) { A = ($81B5); A -= *HL; } B = A; A = D; A &amp;= A; A = 0; // interleaved if (Z) { HL++; A = ($81B6); A -= *HL; } C = A; H = C; A = 0; SRL H RRA E = A; D = H; SRL H RRA L = A; {  HL += DE + B + $F290; // screen buffer start address } EX DE,HL PUSH BC - POP HLdash - A = B; {  HL = C * 24 + A + $F0F8; // visible tiles array } EX DE,HL C = 5;  // self modified do { B = 4; // iterations // self modified do { PUSH HL A = *DE; - POP DEdash // visible tiles array pointer PUSH HLdash select_tile_set(); // call using banked registers {      HLdash = A * 8 + BCdash; } Bdash, Cdash = 8, 24; // iterations, stride {      do { *DEdash = *HLdash++; } {        DEdash += Cdash; } } while (--Bdash); POP HLdash Hdash++; - DE++; HL++; } while (--B); - A = Hdash; A -= 0; // self modified Hdash = A; Ldash++; - A = 20; // self modified A += E; {    if (carry) D++; } E = A; A = $BC; // self modified A += L; {    if (carry) H++; } L = A; {  } while (--C); } next: POP BC {  IY += 32; // stride } } while (--B); return; - {if (indoor_room_index) { } BC = &amp;interior_tiles[0]; - return; } {else { Adash = (((map_position &gt;&gt; 8) &amp; 3) + L) &gt;&gt; 2; } {  L = (Adash &amp; 0x3F) * 7; } {  Adash = (((map_position &amp; 0xFF) &amp; 3) + H) &gt;&gt; 2; } {  Adash = (Adash &amp; 0x3F) + L; } {  Adash = $FF58[Adash]; // 7x5 supertile refs } BC = &amp;exterior_tiles_1[0]; {  if (Adash &gt;= 45) { } BC = &amp;exterior_tiles_2[0]; {    if (Adash &gt;= 139 &amp;&amp; Adash &lt; 204) { } BC = &amp;exterior_tiles_3[0]; } } - return; } HL = map_position; {E = (L &lt; 8) ? 0 : L; } {D = (H &lt; 8) ? 0 : H; } HL = &amp;character_structs[0]; B = character_26_stove1; // the 26 'real' characters {do { if (*HL &amp; characterstruct_BYTE0_BIT6) goto skip; } (stash HL) HL++; // $7613 A = indoor_room_index; {  if (A != *HL) goto unstash_skip; // not in the visible room} {  if (A != 0) goto done_outdoors; } HL++; // $7614 A -= *HL; // A always starts as zero here HL++; // $7615 A -= *HL; HL++; // $7616 A -= *HL; C = A; A = D; {  if (C &lt;= A) goto unstash_skip; // check } A += 32; {  if (A &gt; 0xFF) A = 0xFF; } {  if (C &gt; A) goto unstash_skip; // check } HL--; // $7615 A = 64; *HL += A; HL--; // $7614 *HL -= A; A *= 2; // A == 128 C = A; A = E; {  if (C &lt;= A) goto unstash_skip; // check } A += 40; {  if (A &gt; 0xFF) A = 0xFF; } {  if (C &gt; A) goto unstash_skip; // check } done_outdoors: (unstash HL) {  (stash HL, DE, BC) } sub_C4E0(); {  (unstash BC, DE) } unstash_skip: (unstash HL) {  skip: HL += 7; // stride } } while (--B); return; HL = &amp;map_position; {E = MAX(L - 9, 0); } {D = MAX(H - 9, 0); } B = 7; // 7 iterations HL = $8020; // iterate over non-player characters do { A = *HL; {  if (A == 255) goto next; // no character? } PUSH HL {  HL += 28; } {  if (indoor_room_index != *HL) goto reset; // character not in room } {  C = *--HL; } {  A = *--HL; } divide_by_8_with_rounding(C,A); C = A; {  if (C &lt;= D || C &gt; MIN(D + 34, 255)) goto reset; } {  C = *--HL; } {  A = *--HL; } divide_by_8(C,A); C = A; {  if (C &lt;= E || C &gt; MIN(E + 42, 255)) goto reset; } {  goto pop_next; } reset: POP HL PUSH HL PUSH DE PUSH BC reset_visible_character(); POP BC POP DE pop_next: POP HL {  next: HL += 32; } } while (--B); return; {if (*HL &amp; characterstruct_BYTE0_BIT6) return; } PUSH HL HL = $8020; // iterate over non-player characters - - B = 7; // 7 iterations {do { if (*HL == vischar_BYTE0_EMPTY_SLOT) goto found; // empty slot found?} HL += 32; // stride } while (--B); POP HL return; found: POP DE  // DE = HL (-&gt; visible character list) PUSH HL // resave POP IY  // IY = HL (-&gt; visible character list) PUSH HL // resave PUSH DE DE++; // $8021 etc. HL = &amp;word_81A4; {A = *DE++; } A &amp;= A; if (A == 0) { A = 3; // 3 iterations do { {    BC = *DE * 8; } {    *HL++ = C; } {    *HL++ = B; } DE++; - {  } while (--A); } } else { B = 3; // 3 iterations {do { *HL++ = *DE++; } {  *HL++ = 0; } } while (--B); } sub_AFDF(); if (Z) bounds_check(); POP DE POP HL RET NZ {A = *DE | characterstruct_BYTE0_BIT6; // likely: disable character} *DE = A; A &amp;= characterstruct_BYTE0_MASK; {*HL++ = A; } *HL = 0; PUSH DE DE = &amp;character_meta_data[0]; // commandant {if (A == 0) goto selected; } DE = &amp;character_meta_data[1]; // guard {if (A &lt; 16) goto selected; } DE = &amp;character_meta_data[2]; // dog {if (A &lt; 20) goto selected; } DE = &amp;character_meta_data[3]; // prisoner selected: EX DE,HL {DE += 7; } LDI  // *DE++ = *HL++; B--; LDI  // *DE++ = *HL++; B--; {DE += 11; } LDI  // *DE++ = *HL++; B--; LDI  // *DE++ = *HL++; B--; {DE -= 8; } {memcpy(DE, &amp;word_81A4, 6); } POP HL {HL += 5; } {DE += 7; } A = indoor_room_index; *DE = A; A &amp;= A; JR Z,$C588 {play_speaker(sound_CHARACTER_ENTERS_2); } {play_speaker(sound_CHARACTER_ENTERS_1); } {DE -= 26; } LDI  // *DE++ = *HL++; B--; LDI  // *DE++ = *HL++; B--; {HL -= 2; } A = *HL; {if (A == 0) { } {  DE += 3; } } else { {  byte_A13E = 0; } PUSH DE sub_C651(); {  if (A == 255) { } POP HL {    HL -= 2; } PUSH HL CALL $CB2D POP HL {    DE = HL + 2; } goto $C592; } {  if (A == 128) IY[1] |= vischar_BYTE1_BIT6; // $8021 } POP DE {  memcpy(DE, HL, 3); } } {*DE = 0; } {DE -= 7; } EX DE,HL PUSH HL reset_something(); POP HL sub_C918(); return; // exit via A = *HL; {if (A == character_NONE) return; // might need character_NONE} {if (A &lt; character_26_stove1) goto $C602; // non-object character } {*HL++ = 0xFF; } *HL = 0xFF; {HL += 6; } *HL = 0; {HL += 8; } DE = &amp;movable_items[0]; // stove1 {if (A == character_26_stove1) goto $C5FC; } DE = &amp;movable_items[2]; // stove2 {if (A == character_27_stove2) goto $C5FC; } DE = &amp;movable_items[1]; // crate {memcpy(DE, HL, 6); } return; EX DE,HL get_character_struct(); *HL &amp;= ~characterstruct_BYTE0_BIT6; {DE += 28; } A = *DE; {*++HL = A; } EX DE,HL {HL -= 21; } *HL = 0; {HL += 8; } {DE++; } {if (A == 0) { } divide_array_by_8_with_rounding(HL,DE); } else { B = 3; {  do { *DE++ = *HL; } {  HL += 2; } } while (--B); } {HL -= 21; } A = *HL; {*HL++ = 255; } {*HL++ = 255; } {if (A &gt;= 16 &amp;&amp; A &lt; 20) { // likely character index } {  *HL++ = 255; } *HL = 0; {  if (A &gt;= 18) *HL = 24; } HL--; } *DE++ = *HL++; BC--; *DE++ = *HL++; BC--; return; A = *HL; {if (A == 0xFF) { } {  A = *++HL &amp; characterstruct_BYTE5_MASK_HI; } *HL = A; get_A_indexed_by_C41A(); A &amp;= characterstruct_BYTE5_MASK_LO; A += *HL; {  *HL = A; } } else { PUSH HL {  C = *++HL; } element_A_of_table_7738(); H = 0; A = C; {  if (A == 0xFF) H--; // H = 0xFF } L = A; HL += DE; EX DE,HL A = *DE; if (A == 0xFF) ... POP HL // interleaved ... goto return_255; A &amp;= 0x7F; {  if (A &lt; 40) { } A = *DE; {    if (*HL &amp; (1&lt;&lt;7)) A ^= 0x80; // 762C, 8002, 7672, 7679, 7680, 76A3, 76AA, 76B1, 76B8, 76BF, ... looks quite general} transition(); HL++; A = 0x80; return; } {  A = *DE - 40; } } {HL = word_783A[A]; } A = 0; return; return_255: A = 255; return; {byte_A13E = 0xFF; } {A = character_index + 1;  // character_index = (character_index + 1) % character_26;} {if (A == character_25 + 1) A = 0;  // 26 = highest + 1 character } character_index = A; get_character_struct(); {if (*HL &amp; characterstruct_BYTE0_BIT6) return; } PUSH HL HL++; A = *HL; // characterstruct byte1 {if (A) { } is_item_discoverable_indoors(); {  if (Z) item_discovered(); } } POP HL {HL += 2; } PUSH HL {HL += 3; } A = *HL; {if (A != 0) goto $C6D2; } POP HL return; sub_C651(); {if (A != 0xFF) goto $C6FF; } A = character_index; {if (A == character_0) goto char_is_zero; // player character?} {if (A &gt;= character_12_prisoner) goto char_ge_12; } {*HL++ ^= 0x80; } {if (A &amp; 7) (*HL) -= 2; } (*HL)++; // weird // i.e -1 or +1 POP HL return; {char_is_zero: A = *HL &amp; 0x7F; // fetching a character index? // sampled = HL = $7617 (characterstruct + 5)} {if (A != 36) goto $C6E4; } char_ge_12: POP DE goto character_event; // exit via DEFB $18,$6F  ; UNUSED? {if (A == 0x80) { } POP DE {  A = DE[-1]; } PUSH HL {  if (A == 0) { } PUSH DE DE = &amp;word_81A4; B = 2; // 2 iters do { A = *HL++; A &amp;= A; // clear flags // might not need to show A &gt;&gt;= 1; {      *DE++ = A; } } while (--B); HL = &amp;word_81A4; POP DE } {  if (DE[-1] == 0) A = 2; else A = 6; } EX AF,AF' B = 0; increment_DE_by_diff(); DE++; HL++; increment_DE_by_diff(); POP HL A = B; {  if (A != 2) return; } {  DE -= 2; } HL--; {  *DE = (*HL &amp; 0xFC) &gt;&gt; 2; // mask } {  if ((*HL &amp; 3) &lt; 2) { // mask  // sampled HL = 78fa,794a,78da,791e,78e2,790e,796a,790e,791e,7962,791a =&gt; door_positions } {    HL += 5; } } else { {    HL -= 3; } } {  A = *DE++ } {  if (A) { } LDI LDI LDI DE--; } else { B = 3; do { A = *HL; A &amp;= A; // clear flags RRA *DE = A; HL++; DE++; } while (--B) DE--; } } else { POP DE {  A = DE[-1] } A &amp;= A;     // if (A == 0) ... A = 2;      // interleaving again JR Z,$C779  // goto $C779; A = 6; EX AF,AF' B = 0; increment_DE_by_diff() HL++; DE++; increment_DE_by_diff() DE++; A = B; {  if (A != 2) return; } } DE++; EX DE,HL A = *HL; {if (A == 0xFF) return; } if ((A &amp; (1&lt;&lt;7)) != 0) ... HL++;       // interleaved ... goto exit; (*HL)++; return; exit: (*HL)--; return; - C = Adash; // ie. banked A // some maximum value - {A = *DE - *HL; // delta } if (A == 0) { B++; return; } else if (A &lt; 0) { A = -A; // absolute {  if (A &gt;= C) A = C; } {  *DE += A; } return; } {else { if (A &gt;= C) A = C; } {  *DE -= A; } return; } {HL = &amp;character_structs[A]; } return; A = *HL; {if (A &gt;= character_7_prisoner &amp;&amp; A &lt;= character_12_prisoner) goto character_sleeps; } {if (A &gt;= character_18_prisoner &amp;&amp; A &lt;= character_22_prisoner) goto character_sits; } PUSH HL HL = character_to_event_handler_index_map; B = 24; // 24 iterations {do { if (A == *HL) goto call_action; } {  HL += 2; } } while (--B); POP HL *HL = 0; // no action return; {call_action: goto character_event_handlers[*++HL]; } { 0xA6,  0 }, { 0xA7,  0 }, { 0xA8,  1 }, { 0xA9,  1 }, { 0x05,  0 }, { 0x06,  1 }, { 0x85,  3 }, { 0x86,  3 }, { 0x0E,  2 }, { 0x0F,  2 }, { 0x8E,  0 }, { 0x8F,  1 }, { 0x10,  5 }, { 0x11,  5 }, { 0x90,  0 }, { 0x91,  1 }, { 0xA0,  0 }, { 0xA1,  1 }, { 0x2A,  7 }, { 0x2C,  8 }, // sleeps { 0x2B,  9 }, // sits { 0xA4,  6 }, { 0x24, 10 }, // released from solitary { 0x25,  4 }, // morale related struct foo character_event_handlers[] = { &amp;charevnt_pop_hl_and_write_08FF_to_it, &amp;charevnt_pop_hl_and_write_10FF_to_it, &amp;charevnt_pop_hl_and_write_38FF_to_it, &amp;charevnt_pop_hl_and_check_varA13E, &amp;charevnt_zero_morale_1, &amp;charevnt_pop_hl_and_check_varA13E_anotherone, &amp;charevnt_C845, &amp;charevnt_pop_hl_and_write_0005_to_it, &amp;charevnt_pop_hl_and_player_sleeps, &amp;charevnt_pop_hl_and_player_sits, &amp;charevnt_released_from_solitary, }; {morale_1 = 0; } goto charevnt_pop_hl_and_write_08FF_to_it; POP HL {*HL++ = 0x03; } *HL   = 0x15; return; POP HL {*HL++ = 0xA4; } *HL   = 0x03; {automatic_player_counter = 0; // automatic control } {set_target_location(0x2500); return; } C = 0x10; goto exit; C = 0x38; goto exit; C = 0x08; exit: POP HL {*HL++ = 0xFF; } *HL   = C; return; POP HL {if (byte_A13E == 0) goto varA13E_is_zero; else goto sub_A3F3; } POP HL {if (byte_A13E == 0) goto varA13E_is_zero_anotherone; else goto sub_A4D3; } POP HL {*HL++ = 0x05; } *HL   = 0x00; return; POP HL goto player_sits; POP HL goto player_sleeps; {byte_A13E = 0; } {if (bell) guards_persue_player(); } {if (suspicious_player_related != 0 &amp;&amp; --suspicious_player_related != 0) { } {  item_structs[item_FOOD].item &amp;= ~itemfood_POISONED; } C = item_FOOD; item_discovered(); } IY = $8020; // iterate over non-player characters B = 7; // iterations do { - {  if (IY[1] != room_NONE) { // likely a room index } {    A = IY[0] &amp; 31; // character index } {    if (A &lt; 20) { } - is_item_discoverable(); {      if (red_flag || automatic_player_counter &gt; 0) guards_follow_suspicious_player(); } - {      if (A &gt; 15) { // 16,17,18,19  // could these be the dogs? } {        if (item_structs[item_FOOD].room &amp; itemstruct_ROOM_FLAG_ITEM_NEARBY) IY[1] = 3; } } // if food is nowhere assign it to room_3_hut2right? is IY[1] a room ref? check this } sub_C918(); } - {  IY += 32; // stride } {} while (--B); } {if (!red_flag &amp;&amp; (morale_1 || automatic_player_counter == 0)) { } IY = $8000; sub_C918(); } return; A = IY[7]; // $8007 etc. B = A; A &amp;= vischar_BYTE7_MASK; if (A) { {  IY[7] = --B; // decrement but don't affect flags } return; } {HL = IY; } {A = *++HL; // HL is ? } {if (A != 0) { } {  if (A == 1) { } PUSH HL - POP DEdash {    DEdash += 3; } HLdash = &amp;player_map_position_x; *DEdash++ = *HLdash++; *DEdash++ = *HLdash++; - goto jump_c9c0; } {  else if (A == 2) { } {    if (automatic_player_counter) goto $C932; // jump into case 1 } {    *HL++ = 0; } goto $CB23; } {  else if (A == 3) { } PUSH HL EX DE,HL {    if (item_structs[item_FOOD].room &amp; itemstruct_ROOM_FLAG_ITEM_NEARBY) { } HL++; {      DE += 3; } *DE++ = *HL++; *DE++ = *HL++; POP HL goto jump_c9c0; } else { A = 0; *DE = A; EX DE,HL {      *++HL = 0xFF; } {      *++HL = 0; } POP HL goto $CB23; } } {  else if (A == 4) { } PUSH HL A = bribed_character; {    if (A != 0xFF) { } - B = 7; // 7 iterations HL = $8020; // iterate over non-player characters do { {        if (*HL == A) goto found_bribed; } {        HL += 32; } } while (--B); } POP HL {    *HL++ = 0; } goto $CB23; {found_bribed: HL += 15; } POP DE PUSH DE {    DE += 3; } {    if (indoor_room_index) { } divide_array_by_8_with_rounding(HL,DE); } else { *DE++ = *HL++; HL++; *DE++ = *HL++; } POP HL goto jump_c9c0; } } {A = HL[1]; } {if (A == 0) goto sub_C918:$C9F5; } jump_c9c0: A = *HL; // HL is $8001 - Cdash = A; {if (indoor_room_index) { } HLdash = &amp;A_widened_to_BC; } else { {  if (Cdash &amp; vischar_BYTE1_BIT6) { } HLdash = &amp;BC_becomes_A_times_4; } else { HLdash = &amp;BC_becomes_A_times_8; } } ($CA13) = HLdash; // self-modify sub_CA11:$CA13 ($CA4B) = HLdash; // self-modify sub_CA49:$CA4B - {if (IY[7] &amp; vischar_BYTE7_BIT5) goto bit5set; // I could 'else' this chunk.} {HL += 3; } sub_CA11(); if (Z) { sub_CA49(); if (Z) goto $CA81; } if (A == IY[13]) // sampled IY=$8040,$8020,$8000 return; {IY[13] = A | vischar_BYTE13_BIT7; } return; {bit5set: L += 4; } sub_CA49(); if (!Z) goto $C9F5; sub_CA11(); if (!Z) goto $C9F5; HL--; sub_CA91(); return; // exit via A = *HL; // sampled HL=$8004,$8044,$8064,$8084 BC_becomes_A_times_8(); // self modified by R$C9DA {HL += 11; // -&gt; position on Y axis ($800F etc.) } {E = *HL++; } D = *HL; - DE -= BC; if (DE) { if (DE &gt; 0) { // +ve {    if (D != 0   || E &gt;= 3)  { A = 8; return; } } else { // -ve } {    if (D != 255 || E &lt; 254) { A = 4; return; } } } } - {HL -= 11; } IY[7] |= vischar_BYTE7_BIT5; A = 0; return; A = *HL; // sampled HL=$8025,$8065,$8005 BC_becomes_A_times_8(); // self modified by $C9DD {HL += 12; // position on X axis ($8011 etc.) } {E = *HL++; } D = *HL; - DE -= BC; if (DE) { if (DE &gt; 0) { // +ve {    if (D != 0   || E &gt;= 3)  { A = 5; return; } } else { // -ve } {    if (D != 255 || E &lt; 254) { A = 7; return; } } } } - {HL -= 14; } IY[7] &amp;= ~vischar_BYTE7_BIT5; A = 0; return; A = IY[1]; C = A; A &amp;= vischar_BYTE1_MASK; if (A) { {  if (A == 1) { } A = bribed_character; {    if (A == IY[0]) { use_bribe(); return; } // exit via} else { solitary(); return; } } // exit via {  else if (A == 2 || A == 4) { return; } } PUSH HL HL = &amp;item_structs[item_FOOD].item; {  if ((*HL &amp; itemfood_POISONED) == 0) A = 32; else A = 255; } suspicious_player_related = A; POP HL {  HL -= 2; } {  *HL = 0; } goto sub_C918:$C9F5; } {if (C &amp; vischar_BYTE1_BIT6) { } {  C = *--HL; // 80a3, 8083, 8063, 8003 // likely target location} {  A = *--HL; } PUSH HL element_A_of_table_7738(); POP HL {  DE += C; } A = *DE; {  if (*HL &amp; vischar_BYTE2_BIT7) A ^= 0x80; } PUSH AF {  A = *HL++; // $8002, ... } {  if (A &amp; vischar_BYTE2_BIT7) (*HL) -= 2; // $8003, ... // likely target location } (*HL)++; // likely target location POP AF get_door_position(); // door related {  A = (*HL &gt;&gt; 2) &amp; 0x3F; // *HL = $790E, $7962, $795E =&gt; door position thingy } IY[28] = A; // IY=$8000 =&gt; $801C {  A = *HL &amp; 3; // door position thingy, lowest two bits -- index?} {  if (A &lt; 2) HL += 5; else HL -= 3; // delta of 8 - related to door stride stuff? } PUSH HL {  HL = IY; } {  if (L == 0) { // player's vischar only } HL++; // $8000 -&gt; $8001 {    *HL++ &amp;= ~vischar_BYTE1_BIT6; } CALL $CB23 } POP HL transition(); BC = sound_CHARACTER_ENTERS_1; play_speaker(); return; } {HL -= 2; } A = *HL; // $8002 etc. // likely target location {if (A == 0xFF) goto $CB23; } HL++; {if (A &amp; vischar_BYTE2_BIT7) { } {  (*HL) -= 2; } // $8003 etc. } else { (*HL)++; HL--; } PUSH HL sub_C651(); {if (A == 0xFF) { } POP HL {  if (L != 0x02) { // if not player's vischar } {    A = IY[0] &amp; vischar_BYTE0_MASK; } if (A == 0) { {      A = *HL &amp; vischar_BYTE2_MASK; } {      if (A == 36) goto $CB46; // character index } A = 0; } // self modified? (suspect not - just countering next if statement) {    if (A == 12) goto $CB50; } } PUSH HL character_event(); POP HL A = *HL; {  if (A == 0) return; } goto $CB23; {  *HL++ = *HL ^ 0x80; } {  if (A &amp; (1&lt;&lt;7)) { // which flag is this? } {    (*HL) -= 2; } } (*HL)++ HL--; A = 0; return; } // strictly the terminating } is after the following unreferenced bytes</td>
</tr>
<tr>
<td class="address"><a name="45030"></a>AFE6</td>
<td class="instruction">JP NZ,$B0FE</td>
</tr>
<tr>
<td class="address"><a name="45033"></a>AFE9</td>
<td class="instruction">PUSH BC</td>
</tr>
<tr>
<td class="address"><a name="45034"></a>AFEA</td>
<td class="instruction">PUSH HL</td>
</tr>
<tr>
<td class="address"><a name="45035"></a>AFEB</td>
<td class="instruction">LD A,$0E</td>
</tr>
<tr>
<td class="address"><a name="45037"></a>AFED</td>
<td class="instruction">ADD A,L</td>
</tr>
<tr>
<td class="address"><a name="45038"></a>AFEE</td>
<td class="instruction">LD L,A</td>
</tr>
<tr>
<td class="routineComment" colspan="3">
<a name="45039"></a>
<div class="comments">
<div class="paragraph">
--------
</div>
</div>
</td>
</tr>
<tr>
<td class="address">AFEF</td>
<td class="instruction">LD C,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45040"></a>AFF0</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="address"><a name="45041"></a>AFF1</td>
<td class="instruction">LD B,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45042"></a>AFF2</td>
<td class="instruction">EX DE,HL</td>
</tr>
<tr>
<td class="address"><a name="45043"></a>AFF3</td>
<td class="instruction">LD HL,($81A4)</td>
</tr>
<tr>
<td class="address"><a name="45046"></a>AFF6</td>
<td class="instruction">LD A,$04</td>
</tr>
<tr>
<td class="address"><a name="45048"></a>AFF8</td>
<td class="instruction">ADD A,C</td>
</tr>
<tr>
<td class="address"><a name="45049"></a>AFF9</td>
<td class="instruction">LD C,A</td>
</tr>
<tr>
<td class="address"><a name="45050"></a>AFFA</td>
<td class="instruction">JR NC,$AFFE</td>
</tr>
<tr>
<td class="address"><a name="45052"></a>AFFC</td>
<td class="instruction">INC B</td>
</tr>
<tr>
<td class="address"><a name="45053"></a>AFFD</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="label"><a name="45054"></a>AFFE</td>
<td class="instruction">SBC HL,BC</td>
</tr>
<tr>
<td class="address"><a name="45056"></a>B000</td>
<td class="instruction">JR Z,$B014</td>
</tr>
<tr>
<td class="address"><a name="45058"></a>B002</td>
<td class="instruction">JP NC,$B0FC</td>
</tr>
<tr>
<td class="address"><a name="45061"></a>B005</td>
<td class="instruction">SUB $08</td>
</tr>
<tr>
<td class="address"><a name="45063"></a>B007</td>
<td class="instruction">LD C,A</td>
</tr>
<tr>
<td class="address"><a name="45064"></a>B008</td>
<td class="instruction">JR NC,$B00C</td>
</tr>
<tr>
<td class="address"><a name="45066"></a>B00A</td>
<td class="instruction">DEC B</td>
</tr>
<tr>
<td class="address"><a name="45067"></a>B00B</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="label"><a name="45068"></a>B00C</td>
<td class="instruction">LD HL,($81A4)</td>
</tr>
<tr>
<td class="address"><a name="45071"></a>B00F</td>
<td class="instruction">SBC HL,BC</td>
</tr>
<tr>
<td class="address"><a name="45073"></a>B011</td>
<td class="instruction">JP C,$B0FC</td>
</tr>
<tr>
<td class="label"><a name="45076"></a>B014</td>
<td class="instruction">EX DE,HL</td>
</tr>
<tr>
<td class="address"><a name="45077"></a>B015</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="routineComment" colspan="3">
<a name="45078"></a>
<div class="comments">
<div class="paragraph">
--------
</div>
</div>
</td>
</tr>
<tr>
<td class="address">B016</td>
<td class="instruction">LD C,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45079"></a>B017</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="address"><a name="45080"></a>B018</td>
<td class="instruction">LD B,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45081"></a>B019</td>
<td class="instruction">EX DE,HL</td>
</tr>
<tr>
<td class="address"><a name="45082"></a>B01A</td>
<td class="instruction">LD HL,($81A6)</td>
</tr>
<tr>
<td class="address"><a name="45085"></a>B01D</td>
<td class="instruction">LD A,$04</td>
</tr>
<tr>
<td class="address"><a name="45087"></a>B01F</td>
<td class="instruction">ADD A,C</td>
</tr>
<tr>
<td class="address"><a name="45088"></a>B020</td>
<td class="instruction">LD C,A</td>
</tr>
<tr>
<td class="address"><a name="45089"></a>B021</td>
<td class="instruction">JR NC,$B025</td>
</tr>
<tr>
<td class="address"><a name="45091"></a>B023</td>
<td class="instruction">INC B</td>
</tr>
<tr>
<td class="address"><a name="45092"></a>B024</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="label"><a name="45093"></a>B025</td>
<td class="instruction">SBC HL,BC</td>
</tr>
<tr>
<td class="address"><a name="45095"></a>B027</td>
<td class="instruction">JR Z,$B03B</td>
</tr>
<tr>
<td class="address"><a name="45097"></a>B029</td>
<td class="instruction">JP NC,$B0FC</td>
</tr>
<tr>
<td class="address"><a name="45100"></a>B02C</td>
<td class="instruction">SUB $08</td>
</tr>
<tr>
<td class="address"><a name="45102"></a>B02E</td>
<td class="instruction">LD C,A</td>
</tr>
<tr>
<td class="address"><a name="45103"></a>B02F</td>
<td class="instruction">JR NC,$B033</td>
</tr>
<tr>
<td class="address"><a name="45105"></a>B031</td>
<td class="instruction">DEC B</td>
</tr>
<tr>
<td class="address"><a name="45106"></a>B032</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="label"><a name="45107"></a>B033</td>
<td class="instruction">LD HL,($81A6)</td>
</tr>
<tr>
<td class="address"><a name="45110"></a>B036</td>
<td class="instruction">SBC HL,BC</td>
</tr>
<tr>
<td class="address"><a name="45112"></a>B038</td>
<td class="instruction">JP C,$B0FC</td>
</tr>
<tr>
<td class="label"><a name="45115"></a>B03B</td>
<td class="instruction">EX DE,HL</td>
</tr>
<tr>
<td class="address"><a name="45116"></a>B03C</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="routineComment" colspan="3">
<a name="45117"></a>
<div class="comments">
<div class="paragraph">
--------
</div>
</div>
</td>
</tr>
<tr>
<td class="address">B03D</td>
<td class="instruction">LD C,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45118"></a>B03E</td>
<td class="instruction">LD A,($81A8)</td>
</tr>
<tr>
<td class="address"><a name="45121"></a>B041</td>
<td class="instruction">SUB C</td>
</tr>
<tr>
<td class="address"><a name="45122"></a>B042</td>
<td class="instruction">JR NC,$B046</td>
</tr>
<tr>
<td class="address"><a name="45124"></a>B044</td>
<td class="instruction">NEG</td>
</tr>
<tr>
<td class="label"><a name="45126"></a>B046</td>
<td class="instruction">CP $18</td>
</tr>
<tr>
<td class="address"><a name="45128"></a>B048</td>
<td class="instruction">JP NC,$B0FC</td>
</tr>
<tr>
<td class="address"><a name="45131"></a>B04B</td>
<td class="instruction">LD A,(IY+$01)</td>
</tr>
<tr>
<td class="address"><a name="45134"></a>B04E</td>
<td class="instruction">AND $0F</td>
</tr>
<tr>
<td class="address"><a name="45136"></a>B050</td>
<td class="instruction">CP $01</td>
</tr>
<tr>
<td class="address"><a name="45138"></a>B052</td>
<td class="instruction">JR NZ,$B071</td>
</tr>
<tr>
<td class="address"><a name="45140"></a>B054</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="address"><a name="45141"></a>B055</td>
<td class="instruction">PUSH HL</td>
</tr>
<tr>
<td class="address"><a name="45142"></a>B056</td>
<td class="instruction">DEC L</td>
</tr>
<tr>
<td class="address"><a name="45143"></a>B057</td>
<td class="instruction">LD A,L</td>
</tr>
<tr>
<td class="address"><a name="45144"></a>B058</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="address"><a name="45145"></a>B059</td>
<td class="instruction">JR NZ,$B071</td>
</tr>
<tr>
<td class="address"><a name="45147"></a>B05B</td>
<td class="instruction">LD A,($AF8E)</td>
</tr>
<tr>
<td class="address"><a name="45150"></a>B05E</td>
<td class="instruction">CP (IY+$00)</td>
</tr>
<tr>
<td class="address"><a name="45153"></a>B061</td>
<td class="instruction">JR NZ,$B068</td>
</tr>
<tr>
<td class="address"><a name="45155"></a>B063</td>
<td class="instruction">CALL <a class="link" href="45319.html">$B107</a></td>
</tr>
<tr>
<td class="address"><a name="45158"></a>B066</td>
<td class="instruction">JR $B071</td>
</tr>
<tr>
<td class="label"><a name="45160"></a>B068</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="address"><a name="45161"></a>B069</td>
<td class="instruction">POP BC</td>
</tr>
<tr>
<td class="address"><a name="45162"></a>B06A</td>
<td class="instruction">PUSH IY</td>
</tr>
<tr>
<td class="address"><a name="45164"></a>B06C</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="address"><a name="45165"></a>B06D</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="address"><a name="45166"></a>B06E</td>
<td class="instruction">JP <a class="link" href="52120.html">$CB98</a></td>
</tr>
<tr>
<td class="label"><a name="45169"></a>B071</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="address"><a name="45170"></a>B072</td>
<td class="instruction">DEC L</td>
</tr>
<tr>
<td class="address"><a name="45171"></a>B073</td>
<td class="instruction">LD A,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45172"></a>B074</td>
<td class="instruction">CP $1A</td>
</tr>
<tr>
<td class="address"><a name="45174"></a>B076</td>
<td class="instruction">JR C,$B0B9</td>
</tr>
<tr>
<td class="address"><a name="45176"></a>B078</td>
<td class="instruction">PUSH HL</td>
</tr>
<tr>
<td class="address"><a name="45177"></a>B079</td>
<td class="instruction">EX AF,AF'</td>
</tr>
<tr>
<td class="address"><a name="45178"></a>B07A</td>
<td class="instruction">LD A,$11</td>
</tr>
<tr>
<td class="address"><a name="45180"></a>B07C</td>
<td class="instruction">ADD A,L</td>
</tr>
<tr>
<td class="address"><a name="45181"></a>B07D</td>
<td class="instruction">LD L,A</td>
</tr>
<tr>
<td class="address"><a name="45182"></a>B07E</td>
<td class="instruction">EX AF,AF'</td>
</tr>
<tr>
<td class="address"><a name="45183"></a>B07F</td>
<td class="instruction">LD BC,$0723</td>
</tr>
<tr>
<td class="address"><a name="45186"></a>B082</td>
<td class="instruction">CP $1C</td>
</tr>
<tr>
<td class="address"><a name="45188"></a>B084</td>
<td class="instruction">LD A,(IY+$0E)</td>
</tr>
<tr>
<td class="address"><a name="45191"></a>B087</td>
<td class="instruction">JR NZ,$B08F</td>
</tr>
<tr>
<td class="address"><a name="45193"></a>B089</td>
<td class="instruction">DEC L</td>
</tr>
<tr>
<td class="address"><a name="45194"></a>B08A</td>
<td class="instruction">DEC L</td>
</tr>
<tr>
<td class="address"><a name="45195"></a>B08B</td>
<td class="instruction">LD C,$36</td>
</tr>
<tr>
<td class="address"><a name="45197"></a>B08D</td>
<td class="instruction">XOR $01</td>
</tr>
<tr>
<td class="label"><a name="45199"></a>B08F</td>
<td class="instruction">AND A</td>
</tr>
<tr>
<td class="address"><a name="45200"></a>B090</td>
<td class="instruction">JR NZ,$B09D</td>
</tr>
<tr>
<td class="address"><a name="45202"></a>B092</td>
<td class="instruction">LD A,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45203"></a>B093</td>
<td class="instruction">CP C</td>
</tr>
<tr>
<td class="address"><a name="45204"></a>B094</td>
<td class="instruction">JR Z,$B0B8</td>
</tr>
<tr>
<td class="address"><a name="45206"></a>B096</td>
<td class="instruction">JR C,$B09A</td>
</tr>
<tr>
<td class="address"><a name="45208"></a>B098</td>
<td class="instruction">DEC (HL)</td>
</tr>
<tr>
<td class="address"><a name="45209"></a>B099</td>
<td class="instruction">DEC (HL)</td>
</tr>
<tr>
<td class="label"><a name="45210"></a>B09A</td>
<td class="instruction">INC (HL)</td>
</tr>
<tr>
<td class="address"><a name="45211"></a>B09B</td>
<td class="instruction">JR $B0B8</td>
</tr>
<tr>
<td class="label"><a name="45213"></a>B09D</td>
<td class="instruction">CP $01</td>
</tr>
<tr>
<td class="address"><a name="45215"></a>B09F</td>
<td class="instruction">JR NZ,$B0A9</td>
</tr>
<tr>
<td class="address"><a name="45217"></a>B0A1</td>
<td class="instruction">LD A,C</td>
</tr>
<tr>
<td class="address"><a name="45218"></a>B0A2</td>
<td class="instruction">ADD A,B</td>
</tr>
<tr>
<td class="address"><a name="45219"></a>B0A3</td>
<td class="instruction">CP (HL)</td>
</tr>
<tr>
<td class="address"><a name="45220"></a>B0A4</td>
<td class="instruction">JR Z,$B0B8</td>
</tr>
<tr>
<td class="address"><a name="45222"></a>B0A6</td>
<td class="instruction">INC (HL)</td>
</tr>
<tr>
<td class="address"><a name="45223"></a>B0A7</td>
<td class="instruction">JR $B0B8</td>
</tr>
<tr>
<td class="label"><a name="45225"></a>B0A9</td>
<td class="instruction">CP $02</td>
</tr>
<tr>
<td class="address"><a name="45227"></a>B0AB</td>
<td class="instruction">JR NZ,$B0B2</td>
</tr>
<tr>
<td class="address"><a name="45229"></a>B0AD</td>
<td class="instruction">LD A,C</td>
</tr>
<tr>
<td class="address"><a name="45230"></a>B0AE</td>
<td class="instruction">SUB B</td>
</tr>
<tr>
<td class="address"><a name="45231"></a>B0AF</td>
<td class="instruction">LD (HL),A</td>
</tr>
<tr>
<td class="address"><a name="45232"></a>B0B0</td>
<td class="instruction">JR $B0B8</td>
</tr>
<tr>
<td class="label"><a name="45234"></a>B0B2</td>
<td class="instruction">LD A,C</td>
</tr>
<tr>
<td class="address"><a name="45235"></a>B0B3</td>
<td class="instruction">SUB B</td>
</tr>
<tr>
<td class="address"><a name="45236"></a>B0B4</td>
<td class="instruction">CP (HL)</td>
</tr>
<tr>
<td class="address"><a name="45237"></a>B0B5</td>
<td class="instruction">JR Z,$B0B8</td>
</tr>
<tr>
<td class="address"><a name="45239"></a>B0B7</td>
<td class="instruction">DEC (HL)</td>
</tr>
<tr>
<td class="label"><a name="45240"></a>B0B8</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="label"><a name="45241"></a>B0B9</td>
<td class="instruction">POP BC</td>
</tr>
<tr>
<td class="address"><a name="45242"></a>B0BA</td>
<td class="instruction">LD A,L</td>
</tr>
<tr>
<td class="address"><a name="45243"></a>B0BB</td>
<td class="instruction">ADD A,$0D</td>
</tr>
<tr>
<td class="address"><a name="45245"></a>B0BD</td>
<td class="instruction">LD L,A</td>
</tr>
<tr>
<td class="address"><a name="45246"></a>B0BE</td>
<td class="instruction">LD A,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45247"></a>B0BF</td>
<td class="instruction">AND $7F</td>
</tr>
<tr>
<td class="address"><a name="45249"></a>B0C1</td>
<td class="instruction">JR Z,$B0DB</td>
</tr>
<tr>
<td class="address"><a name="45251"></a>B0C3</td>
<td class="instruction">INC L</td>
</tr>
<tr>
<td class="address"><a name="45252"></a>B0C4</td>
<td class="instruction">LD A,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45253"></a>B0C5</td>
<td class="instruction">XOR $02</td>
</tr>
<tr>
<td class="address"><a name="45255"></a>B0C7</td>
<td class="instruction">CP (IY+$0E)</td>
</tr>
<tr>
<td class="address"><a name="45258"></a>B0CA</td>
<td class="instruction">JR Z,$B0DB</td>
</tr>
<tr>
<td class="address"><a name="45260"></a>B0CC</td>
<td class="instruction">LD (IY+$0D),$80</td>
</tr>
<tr>
<td class="label"><a name="45264"></a>B0D0</td>
<td class="instruction">LD A,(IY+$07)</td>
</tr>
<tr>
<td class="address"><a name="45267"></a>B0D3</td>
<td class="instruction">AND $F0</td>
</tr>
<tr>
<td class="address"><a name="45269"></a>B0D5</td>
<td class="instruction">OR $05</td>
</tr>
<tr>
<td class="address"><a name="45271"></a>B0D7</td>
<td class="instruction">LD (IY+$07),A</td>
</tr>
<tr>
<td class="address"><a name="45274"></a>B0DA</td>
<td class="instruction">RET NZ</td>
</tr>
<tr>
<td class="label"><a name="45275"></a>B0DB</td>
<td class="instruction">LD C,(IY+$0E)</td>
</tr>
<tr>
<td class="address"><a name="45278"></a>B0DE</td>
<td class="instruction">LD B,$00</td>
</tr>
<tr>
<td class="address"><a name="45280"></a>B0E0</td>
<td class="instruction">LD HL,$B0F8</td>
</tr>
<tr>
<td class="address"><a name="45283"></a>B0E3</td>
<td class="instruction">ADD HL,BC</td>
</tr>
<tr>
<td class="address"><a name="45284"></a>B0E4</td>
<td class="instruction">LD A,(HL)</td>
</tr>
<tr>
<td class="address"><a name="45285"></a>B0E5</td>
<td class="instruction">LD (IY+$0D),A</td>
</tr>
<tr>
<td class="address"><a name="45288"></a>B0E8</td>
<td class="instruction">BIT 0,C</td>
</tr>
<tr>
<td class="address"><a name="45290"></a>B0EA</td>
<td class="instruction">JR NZ,$B0F2</td>
</tr>
<tr>
<td class="address"><a name="45292"></a>B0EC</td>
<td class="instruction">RES 5,(IY+$07)</td>
</tr>
<tr>
<td class="address"><a name="45296"></a>B0F0</td>
<td class="instruction">JR $B0D0</td>
</tr>
<tr>
<td class="label"><a name="45298"></a>B0F2</td>
<td class="instruction">SET 5,(IY+$07)</td>
</tr>
<tr>
<td class="address"><a name="45302"></a>B0F6</td>
<td class="instruction">JR $B0D0</td>
</tr>
<tr>
<td class="routineComment" colspan="3">
<a name="45304"></a>
<div class="comments">
<div class="paragraph">
(&lt;- sub_AFDF)
</div>
</div>
</td>
</tr>
<tr>
<td class="address">B0F8</td>
<td class="instruction">DEFB $85,$84,$87,$88</td>
</tr>
<tr>
<td class="label"><a name="45308"></a>B0FC</td>
<td class="instruction">POP HL</td>
</tr>
<tr>
<td class="address"><a name="45309"></a>B0FD</td>
<td class="instruction">POP BC</td>
</tr>
<tr>
<td class="label"><a name="45310"></a>B0FE</td>
<td class="instruction">LD A,L</td>
</tr>
<tr>
<td class="address"><a name="45311"></a>B0FF</td>
<td class="instruction">ADD A,$20</td>
</tr>
<tr>
<td class="address"><a name="45313"></a>B101</td>
<td class="instruction">LD L,A</td>
</tr>
<tr>
<td class="address"><a name="45314"></a>B102</td>
<td class="instruction">DEC B</td>
</tr>
<tr>
<td class="address"><a name="45315"></a>B103</td>
<td class="instruction">JP NZ,$AFE4</td>
</tr>
<tr>
<td class="address"><a name="45318"></a>B106</td>
<td class="instruction">RET</td>
</tr>
</table>
<table class="prevNext">
<tr>
<td class="prev">Prev: <a class="link" href="44943.html">AF8F</a></td>
<td class="up">Up: <a class="link" href="../maps/all.html#45023">Map</a></td>
<td class="next">Next: <a class="link" href="45319.html">B107</a></td>
</tr>
</table>
<div class="footer">
<div class="release">The incomplete The Great Escape disassembly 20130626</div>
<div class="copyright">&copy; Denton Designs. Ocean. David Thomas.</div>
<div class="created">Created using <a class="link" href="http://pyskool.ca/?page_id=177">SkoolKit</a> 3.3.2.</div>
</div>
</body>
</html>